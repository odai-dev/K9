Background

The K9 repository (Flask application) is currently tailored for development/replit use. It uses Flask‑SQLAlchemy with fallback to SQLite and creates a default admin on first run
raw.githubusercontent.com
. The system documentation confirms that PostgreSQL is the primary database and Gunicorn is the intended production WSGI server
raw.githubusercontent.com
. The configuration section also stresses that deployments must set DATABASE_URL to a PostgreSQL DSN and provide a SESSION_SECRET
raw.githubusercontent.com
, and manual deployment guidance notes the need to configure PostgreSQL, environment variables, Gunicorn, a reverse proxy and process management
raw.githubusercontent.com
. Currently there is no Dockerfile or docker‑compose configuration.

Objectives

Create a Docker‑based production deployment that builds the Flask application, installs Python dependencies, connects to PostgreSQL, runs database migrations, and serves the app via Gunicorn behind an Nginx‑style reverse proxy.

Use PostgreSQL as the sole database by removing the SQLite fallback and ensuring the environment variable DATABASE_URL is mandatory. Postgres engine options (pooling, encoding) must reflect those already used in the code
raw.githubusercontent.com
raw.githubusercontent.com
.

Provide infrastructure to run database migrations on container start using Flask‑Migrate
raw.githubusercontent.com
.

Keep sensitive configuration out of the code. Use environment variables for DATABASE_URL and SESSION_SECRET
raw.githubusercontent.com
 and ensure debug mode is disabled in production
raw.githubusercontent.com
.

Persist uploads and database data via Docker volumes and document where to mount them on the host.

Deliverables

Dockerfile:

Base image: an official slim Python 3.11 image.

Copy the project files.

Install dependencies from pyproject.toml (pip/poetry).

Expose port 5000.

Set environment variables PYTHONUNBUFFERED=1, FLASK_APP=app.py, FLASK_ENV=production.

Add a startup script/entrypoint that runs flask db upgrade (to apply migrations) and then launches the server via gunicorn app:app --bind 0.0.0.0:5000 --workers <n> (worker count should scale with CPU). Gunicorn is specified as the production server
raw.githubusercontent.com
.

docker‑compose.yml:

Define two services:

db: Use postgres:<suitable‑version>; set POSTGRES_DB, POSTGRES_USER, POSTGRES_PASSWORD; mount a volume db_data to /var/lib/postgresql/data; expose port 5432 if needed.

web: Build from the Dockerfile; depends_on db; set environment variables (DATABASE_URL=postgresql://<user>:<password>@db:5432/<db_name>, SESSION_SECRET=<secure‑random‑string>, FLASK_ENV=production); mount a volume for ./uploads to /app/uploads (the application stores uploads there
raw.githubusercontent.com
 and the docs limit upload size
raw.githubusercontent.com
); expose port 80 or 5000; command should ensure flask db upgrade runs before gunicorn.

Define volumes db_data and uploads for persistence.

Environment variables file (.env.example): Provide a sample file with placeholders for POSTGRES_DB, POSTGRES_USER, POSTGRES_PASSWORD, DATABASE_URL, and SESSION_SECRET. Indicate that in production SESSION_SECRET must be a strong random string and that the default admin credentials (admin/admin123) included in app.py
raw.githubusercontent.com
 must be changed or disabled.

Application configuration changes:

Modify app.py or config.py so that if DATABASE_URL is missing, the application fails loudly instead of falling back to SQLite (suitable for development only).

Ensure the app uses the ProductionConfig when FLASK_ENV=production
raw.githubusercontent.com
. Remove or guard the code that auto‑creates the default admin and calls db.create_all() in production
raw.githubusercontent.com
; migrations should handle schema creation, and the first admin account should be created via a management command or environment variables.

Reverse proxy / SSL guidance: Provide recommended Nginx configuration snippets (outside the scope of docker‑compose if you choose to run Nginx separately) to proxy requests to the Gunicorn container, serve static files efficiently, enable Gzip, and handle SSL termination. The documentation notes the need for a reverse proxy and SSL
raw.githubusercontent.com
.

Deployment instructions:

Step‑by‑step guide to build and run the containers: docker-compose build, docker-compose up -d.

Instructions on setting environment variables (e.g., copy .env.example to .env and fill in real values).

Command to check logs (docker-compose logs web).

Instructions on running tests or performing manual migration commands if needed (e.g., docker-compose exec web flask db migrate).

Recommendations for scaling (e.g., using separate task queue for background jobs if added later) and monitoring.

Update documentation: Add a new “Deployment” section to K9_SYSTEM_DOCUMENTATION.md explaining how to deploy via Docker, summarizing the above steps and referencing the environment settings. Indicate that production uses PostgreSQL exclusively
raw.githubusercontent.com
 and that environment variables must be set accordingly
raw.githubusercontent.com
.