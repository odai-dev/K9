مشكلة عدم عرض الصلاحيات المفعَّلة وحلّها
وصف المشكلة

واجهة إدارة الصلاحيات الحالية لا تظهر الصلاحيات الممنوحة مسبقًا لمسؤولي المشاريع بشكل صحيح. عند فتح صفحة إدارة الصلاحيات لمسؤول مشروع معين (ضمن مشروع محدد)، من المفترض أن ترى جميع الصلاحيات التي يمتلكها ذلك المسؤول بالفعل مفعّلة (ظاهرة بوضع ON أو معلمة بعلامة ✅)، والصلاحيات غير الممنوحة تظهر بشكل غير مفعّل أو بعلامة OFF باهتة. حاليًا هذا لا يحدث – حيث تظهر كل الصلاحيات وكأنها غير مفعّلة حتى لو كان لدى المستخدم بعض تلك الصلاحيات فعليًا. هذا يجعل من الصعب معرفة ما تم منحه مسبقًا لكل مسؤول مشروع.

الوضع الحالي وسبب المشكلة

السبب الأساسي هو أن نظام إدارة الصلاحيات لم يكتمل تنفيذه من جهة البرمجة الخلفية (Back-end). هناك دالة مهمة مسؤولة عن جلب مصفوفة الصلاحيات للمستخدم (get_user_permissions_matrix) لكنها حاليًا لا تقوم بتعبئة الصلاحيات الممنوحة فعليًا من قاعدة البيانات. عند طلب صلاحيات مستخدم من نوع مشروع، تقوم هذه الدالة بإنشاء جميع الخانات بوضع False (أي غير مفعّلة) افتراضيًا ثم تُرجِع النتائج دون تحديد ما هو مGranted له حقًا. بمعنى آخر، النظام لا يتحقق من سجل الصلاحيات الفعلي (جدول sub_permissions) أثناء عرض الصفحة، لذا تظهر كل الخيارات Off بغض النظر عن الواقع.

السبب الثاني يرتبط بطريقة إضافة الصلاحيات سابقًا. وفق التوثيق، تمت تهيئة النظام بحيث يحصل مدير المشروع على صلاحيات افتراضية تلقائيًا في بعض الأقسام دون الحاجة لإدخالها يدويًا في جدول الصلاحيات. على سبيل المثال، مدير المشروع لديه كامل الصلاحيات بشكل افتراضي على قسم المشاريع وبعض الأقسام الأخرى. هذه الصلاحيات “الافتراضية” تم تفعيلها برمجيًا (عن طريق كود يسمح بها تلقائيًا) وليس عن طريق حفظ قيود في قاعدة البيانات. لذلك، حاليًا قد يكون لمسؤول المشروع قدرة على الوصول لأقسام معينة رغم عدم وجود مدخل في جدول sub_permissions. هذا يفسّر why واجهة الإدارة لا تراها – لأنها تعتمد فقط على البيانات المخزنة.

بالإضافة إلى ذلك، وظائف تحديث الصلاحيات نفسها غير مكتملة. دالة update_permission (المفترض أنها تحفظ أي تغيير يقوم به المدير العام للصلاحيات) هي حاليًا مجرد واجهة فارغة تعيد True دون تنفيذ منطق التخزين. هذا يعني أنه عند محاولة إضافة أو إزالة صلاحية عبر الواجهة، التغيير لا يُحفظ فعليًا في قاعدة البيانات. وبالتالي حتى لو بدت لك الصلاحية مفعّلة فور ضغطها، لن يستمر هذا التأثير – وعند إعادة فتح الصفحة ستجد الإعداد رجع كما كان. عدم فعالية عملية الحفظ يؤدي أيضًا إلى أن إلغاء الصلاحية لا ينعكس على اختفاء الميزة من شاشات المستخدم المستهدف.

ملخص السبب: النظام الحالي يعتمد على مجموعة صلاحيات افتراضية مبرمجة للمRoles (مثل مدير المشروع) بدل الاعتماد الكامل على جدول الصلاحيات التفصيلية. ولم يتم بعد ربط واجهة الإدارة بهذه البيانات بشكل صحيح. النتيجة هي فجوة بين ما يملكه المستخدم فعليًا وبين ما تعرضه صفحة إدارة الصلاحيات.

السلوك المتوقع (المطلوب)

المطلوب هو جعل واجهة إدارة الصلاحيات فعّالة وديناميكية بحيث تعكس الحقيقة الفعلية لصلاحيات كل مستخدم. عند فتح صفحة صلاحيات لمسؤول مشروع محدد، يجب أن تقوم المنصة بما يلي:

عرض الصلاحيات الممنوحة حاليًا لهذا المسؤول بشكل واضح: تظهر كعناصر مفعّلة (مثلاً checkbox مؤشر عليه أو زر تبديل في وضع التشغيل ON). بهذه الطريقة يعرف المدير العام أي صلاحيات يمتلكها المستخدم سلفًا دون تكرار منحها.

عرض الصلاحيات غير الممنوحة بشكل مختلف (رمز رمادي أو زر OFF) بحيث يمكن تمييزها. هذا يشير إلى أن هذه الصلاحية معطّلة حاليًا لذلك المستخدم ويمكن للمدير العام تفعيلها إذا لزم الأمر.

تحديث فوري للتغييرات: عند قيام المدير العام بتفعيل صلاحية جديدة أو إلغائها عبر الواجهة، يجب أن يُحفظ هذا التغيير ويُطبَّق فورًا. أي صلاحية يتم تفعيلها يجب أن تظهر مباشرة في شاشات المسؤول المستهدف (وبالمثل إلغاء الصلاحية ينبغي أن يخفي تلك الشاشة/الميزة من المستخدم المستهدف تلقائيًا). وبالطبع عند إعادة فتح صفحة إدارة الصلاحيات لذلك المستخدم، يبقى الوضع (ON/OFF) مطابقًا لما تم ضبطه مسبقًا.

باختصار، يُفترض أن تكون صفحة إدارة الصلاحيات هي المصدر الوحيد للحقيقة فيما يخص ما يملكه كل مستخدم من صلاحيات. كل ما هو مGranted يجب أن يكون ظاهرًا On، وكل ما هو غير مGranted Off بشكل شفاف.

الحل المقترح (التعديلات المطلوبة)

لتحقيق السلوك المطلوب أعلاه، نقترح تنفيذ التعديلات التالية على النظام:

ربط واجهة العرض ببيانات قاعدة البيانات الفعلية للصلاحيات: يجب تعديل وظيفة جلب مصفوفة صلاحيات المستخدم (get_user_permissions_matrix) بحيث تقوم بالاستعلام عن جدول الصلاحيات التفصيلية. أي، بعد إنشاء المصفوفة الافتراضية (المملوءة بقيم False)، تقوم بالبحث عن جميع سجلات SubPermission الخاصة بذلك المستخدم (وللمشروع المحدد إذا كان هناك ترشيح لمشروع). لكل سجل حيث is_granted=True، يجب تعيين القيمة المناسبة في المصفوفة إلى True بدل False. بهذه الطريقة، أي صلاحية مخزنة كفعّالة في قاعدة البيانات ستظهر مفعّلة في الواجهة. (وينبغي أيضًا تمرير project_id للفنكشن لاختيار صلاحيات ذلك المشروع فقط عند اللزوم).

إدراج الصلاحيات الافتراضية ضمن المصفوفة: نظرًا لأن بعض الصلاحيات تُمنح تلقائيًا لمديري المشاريع بدون وجود سجل في قاعدة البيانات (مثال: صلاحيات قسم المشاريع كاملة مفتوحة افتراضيًا)، فيجب أن تُظهرها الواجهة أيضًا كمفعّلة. لتحقيق ذلك، هناك خياران:

الخيار أ: إنشاء سجلات SubPermission افتراضية في قاعدة البيانات عند إنشاء مستخدم جديد بدور مدير مشروع (أو عبر سكربت ترحيل) تتضمن تلك الصلاحيات الافتراضية (مع وضع is_granted=True). بهذه الطريقة تصبح جزءًا من الاستعلام في الخطوة السابقة وتظهر تلقائيًا.

الخيار ب: أو بدلاً من ذلك، إضافة منطق برمجي في دالة المصفوفة يقوم بوضع True على هذه الصلاحيات الافتراضية بشكل مباشر إذا كان المستخدم من نوع Project Manager ولم تكن موجودة في قاعدة البيانات. يمكن الاستفادة من قائمة الصلاحيات المسموح بها افتراضيًا له (الموجودة حاليًا في الكود) لتعيينها. المهم هو ألا تبقى أي صلاحية ممنوحة فعليًا مخفية عن صفحة الإدارة.

تفعيل حفظ التغييرات في قاعدة البيانات: يجب إكمال تنفيذ دالة update_permission (وأيضًا bulk_update_permissions إذا كانت تستخدم) بحيث عند قيام المدير العام بتغيير حالة صلاحية عبر الواجهة، يتم تحديث قاعدة البيانات وفقًا لذلك.具体ً:

عند تفعيل صلاحية لمستخدم: إذا كان هناك سجل موجود في جدول sub_permissions يطابق ذلك المستخدم ونوع الصلاحية (Section/Subsection/Type) والمشروع، يتم تحديث حقل is_granted إلى True. وإن لم يوجد سجل سابق (أي صلاحية جديدة تمامًا لهذا المستخدم)، يتم إنشاء سجل جديد بالقيم المناسبة (user_id, القسم، الفرع، نوع الصلاحية، project_id إن وجد، و is_granted=True).

عند إلغاء صلاحية (تعطيلها): يمكن إما تحديث السجل الموجود بجعل is_granted=False (يفضل الإبقاء على السجل لأغراض التدقيق وسجل التغييرات)، أو حذفه تمامًا. الحفاظ على السجل مع علامة التعطيل أفضل للتوافق مع بنية النظام (هناك عمود is_granted مُصمم لهذا الغرض).

بعد التعديل يجب التأكد من عمل commit للحفظ. بهذه الطريقة أي تعديل من الواجهة ينعكس في قاعدة البيانات مباشرة.

تجدر الإشارة إلى أن الشفرة الحالية تحتوي على قيد وحيد (UniqueConstraint) يضمن عدم تكرار نفس الصلاحية للمستخدم نفسه والمشروع نفسه، لذا يمكن تحديث أو إدراج السجلات بأمان دون خوف من الازدواجية.

تحديث واجهة المستخدم (إذا لزم الأمر): بعد الخطوات أعلاه، غالبية التغيير سيكون في الطبقة الخلفية. لكن يجب التأكد من أن الواجهة (صفحة إدارة الصلاحيات) تستخدم البيانات الجديدة بشكل صحيح. على سبيل المثال، إذا كانت تعتمد على استدعاء AJAX لجلب المصفوفة (من المسار /admin/permissions/user/<id>)، فيجب اختبار أنها تتلقى الآن القيم الصحيحة (True/False) لكل صلاحية. تأكد من أن عناصر التحكم (checkboxes أو toggles) في الصفحة تُضبط حسب تلك القيم عند اختيار المستخدم/المشروع. قد يتطلب الأمر إضافة تحديث فوري للواجهة عند تغيير فلتر المشروع أو بعد إجراء “Bulk Update”. المهم أن تصبح الواجهة متزامنة تمامًا مع قاعدة البيانات: تعرض الحالة الحالية للصلاحيات، وتحدثها فور تغييرها.

اختبار التكامل: بعد تنفيذ ما سبق، يُنصح باختبار السيناريوهات التالية:

فتح صفحة إدارة الصلاحيات لمسؤول مشروع لديه صلاحيات سابقة (افتراضية أو مضافة سابقًا) والتأكد من ظهور هذه الصلاحيات مفعّلة وفق التوقع. مثلاً، مسؤول مشروع يجب أن يظهر أن قسم المشاريع مفعل لديه افتراضيًا، وهكذا لبقية الصلاحيات الافتراضية.

تفعيل صلاحية جديدة لم تكن لديه (مثلاً إعطاء صلاحية تصدير التقارير لمستخدم ليس لديه هذه الصلاحية) ثم التأكد من أنها تظهر On في الواجهة مباشرة، وأن المستخدم المستهدف يستطيع الآن القيام بهذه الوظيفة في نظامه.

إلغاء صلاحية كانت مفعّلة (سواء افتراضية أو مضافة) والتأكد من اختفائها من واجهة المستخدم المستهدف (مثلاً إلغاء صلاحية عرض قائمة الموظفين فيختفي خيار قائمة الموظفين لدى مسؤول المشروع ذلك). وأيضًا التحقق من أن الواجهة الإداريّة تعرضها الآن كمعطّلة.

تجربة إنشاء مستخدم جديد بدور مدير مشروع للتأكد أن الصلاحيات الافتراضية تظهر له مباشرة في صفحة الإدارة (إذا طبقتم خيار إنشاء سجلات افتراضية في قاعدة البيانات). وإن لم تظهر، يمكن استخدام زر "تهيئة الصلاحيات الافتراضية" (إن وجد في الواجهة) أو تنفيذ ذلك يدويًا واستعراض النتيجة.

ملاحظة حول سجل التدقيق

نظامكم يحتوي على سجل تدقيق للصلاحيات (مثل PermissionAuditLog لتسجيل التغييرات). بعد تفعيل التحديثات أعلاه، تأكدوا أن كل تغيير يتم تسجيله بشكل صحيح في هذا السجل (وعدم وجود أخطاء بسبب أن الدوال كانت تعيد True بدون عملية حقيقية). بما أنكم تضيفون عمليات حقيقية (INSERT/UPDATE)، أي إدخال في قاعدة البيانات يجب أن يصاحبه إنشاء سجل تدقيق كما هو مُبرمج في المسارات /permissions/update و/permissions/bulk-update. هذا يضمن تتبع من فعّل أو ألغى أي صلاحية ومتى.

الخلاصة

بعد تطبيق هذه التعديلات، ستصبح دارة الصلاحيات فعالة كما هو مطلوب. أي صلاحية مفتوحة حاليًا لمسؤول مشروع ستظهر بشكل واضح في صفحة الإدارة وهي مفعّلة، مما يسمح للمدير العام برؤية الوضع الراهن بسهولة. كذلك، أي تعديل يجريه عبر الصفحة سيتم تخزينه وتطبيقه فعليًا (وليس شكليًا فقط)، مما يعني أن التحكم بالصلاحيات انتقل ليكون مركزيًا عبر هذه الواجهة. عند إلغاء صلاحية، سيزول تأثيرها من نظام المستخدم المستهدف تلقائيًا، وعند منح صلاحية جديدة ستظهر للمستخدم ضمن شاشاته المخصصة. بهذه الطريقة تحققتم من أن كل شيء يمر عبر إدارة الصلاحيات كما ينبغي، ويصبح لديكم نظام مرن وقابل للإدارة لمختلف الأدوار والصلاحيات في المشروع.

مصادر: تم الاستناد إلى وثائق النظام الداخلية والكود المرفق لفهم المشكلة والحل، منها وثيقة صلاحيات مدير المشروع التي توضح الصلاحيات الافتراضية الممنوحة لهذا الدور، وكذلك مراجعة الشفرة المصدرية (ملف permission_utils.py ووظائف تحديث الصلاحيات) التي أظهرت الأماكن المحتاجة للتعديل. هذه المراجع بيّنت أن بعض الصلاحيات كانت مفعّلة ضمنيًا افتراضيًا دون تسجيلٍ في قاعدة البيانات، وأن منطق العرض والتحديث لم يكتمل تنفيذه بعد – مما قادنا إلى التوصيات أعلاه لإصلاح الخلل وضمان عمل إدارة الصلاحيات بالشكل المنشود.